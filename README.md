</details>

******

<details>
<summary>Linux Mint Virtual Machine </summary>
 <br />
I usually use Debian on UTM but for this project i will be using Linux Mint so that i practiced and tried more than one OS.
I will use this free online VM platform to get access to Linux Mint
- https://www.onworks.net/component/content/article?id=65735:free-linux-mint-online

_Just click on "run online" and it will spin up a new Mint OS machine for you_

<img src="https://i.imgur.com/Zur6MZ1.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

</details>

******

<details>
<summary>Bash Script - Install Java </summary>
 <br />

 As i was using an online platform for the OS everything was brand new so i had to start with installing VIM 

 Then after creating the file and writting the script i had to give permission to the user to execute it. 

<img src="https://i.imgur.com/uJpKHTC.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


<img src="https://i.imgur.com/f29xdTD.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


Breakdown of command that gets java version:
- `java -version` gives you the complete version output.
- `2>&1 > /dev/null` addition does following things: with `2>&1` the error output of the `java -version` command will be discarded by the `/dev/null` file, and `>` redirects the output of `java -version` command to the `/dev/null` file, which is a special type of file, that accepts and discards all input written to it. So described together, this option takes the output, including any errors generated by the `java -version` command and discards it, not showing it on the command-line and silently forwarding it using `|` (pipe) to the next command, which is `grep "java version\|openjdk version"`
- `grep "java version\|openjdk version"` simply finds a line in the output that has "java version" or "openjdk version" in it. The example line will look like this: openjdk version "11.0.16" 2022-07-19
- `awk '{print substr($3,2,2)}` takes the line from the previous output and grabs the third section of the string "11.0.16" and from there grabs the first 2 characters, which will be "11"


*Detailed explanation of `2>&1`:

Every time, we execute a program or a command, operating system opens three files: **standard input**, **standard output**, and **standard error**, and each file gets a file descriptor integer from the OS: 0, 1, and 2, respectively. So 2>&1 simply says redirect standard error (2) to standard output (1). The `&` before `1` in this case, means whatever follows is a file descriptor, not a filename. 

Explanation of `if else` script:
- In the if else checks, we check if the $java_version variable has no value at all or empty value, it means we have no java installation at all
- If you have an older version of java already installed, like 1.6, 1.7, 1.8, then the value of `"$java_version"` will be `"1."` - first 2 characters. So with `"$java_version" == "1."`, we check whether `java_version` variable is `"1."`. This means installing latest java version was not successful, since you still have only the old version.
- In case of success you should get java version which is 11 or higher (`"$java_version" -ge 11`), which will print success message.


</details>

******
<details>
<summary> Bash Script - User Processes Sorted </summary>
 <br />

- Descriptiom:

-Write a bash script using Vim editor that checks all the processes running for the current user (USER env var) and prints out the processes in console.

<img src="https://i.imgur.com/6yaMkeV.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

- The outcome:

<img src="https://i.imgur.com/g1TSfTW.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

******

- Extend the previous script to ask for a user input for sorting the processes output either by memory or CPU consumption, and print the sorted list.

<img src="https://i.imgur.com/JfKXUxh.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

- Extend the previous script to ask additionally for user input about how many processes to print.

<img src="https://i.imgur.com/RCfMG0m.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

the outcome

<img src="https://i.imgur.com/ieHIYU8.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


<img src="https://i.imgur.com/jBBwc4x.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


<img src="https://i.imgur.com/TaeBaIu.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


</details>

******

<details>
<summary> Start NodeJs App </summary>
 <br />

Start Node App
Write a bash script with following logic: 

Install NodeJS and NPM and print out which versions were installed
Download an artifact file from the URL: https://node-envvars-artifact.s3.eu-west-2.amazonaws.com/bootcamp-node-envvars-project-1.0.0.tgz.
Unzip the downloaded file
Set the following needed environment variables: APP_ENV=dev, DB_USER=myuser, DB_PWD=mysecret
Change into the unzipped package directory
Run the NodeJS application by executing the following commands:  npm install and node server.js

<img src="https://i.imgur.com/qmcUS2x.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

<img src="https://i.imgur.com/1pHoTLK.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

Node App Check Status

Extend the script to check after running the application that the application has successfully started and prints out the application's running process and the port where it's listening. 

<img src="https://i.imgur.com/RMWailL.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

<img src="https://i.imgur.com/ubDWPfY.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


</details>

******

<details>
<summary> Start NodeJs App with Service user & Log Directory </summary>
 <br />

Node App with Log Directory

Extend the script to accept a parameter input log_directory: a directory where application will write logs.

The script will check whether the parameter value is a directory name that doesn't exist and will create the directory, if it does exist, it sets the env var LOG_DIR to the directory's absolute path before running the application, so the application can read the LOG_DIR environment variable and write its logs there.

<img src="https://i.imgur.com/K2yGkVw.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

<img src="https://i.imgur.com/FASpnzY.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


Node App with Service user

You've been running the application with your user. But we need to adjust that and create own service user: myapp for the application to run. So extend the script to create the user and then run the application with the service user. 

<img src="https://i.imgur.com/ZmJFv1T.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>

<img src="https://i.imgur.com/8aLf5CK.png" height="80%" width="80%" alt="Disk Sanitization Steps"/>


</details>

******
